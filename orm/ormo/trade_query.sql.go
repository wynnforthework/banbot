// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: trade_query.sql

package ormo

import (
	"context"
)

const addExOrder = `-- name: AddExOrder :one
insert into exorder ("task_id", "inout_id", "symbol", "enter", "order_type", "order_id", "side",
                     "create_at", "price", "average", "amount", "filled", "status", "fee", "fee_type", "update_at")
values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    RETURNING id
`

type AddExOrderParams struct {
	TaskID    int64   `json:"task_id"`
	InoutID   int64   `json:"inout_id"`
	Symbol    string  `json:"symbol"`
	Enter     bool    `json:"enter"`
	OrderType string  `json:"order_type"`
	OrderID   string  `json:"order_id"`
	Side      string  `json:"side"`
	CreateAt  int64   `json:"create_at"`
	Price     float64 `json:"price"`
	Average   float64 `json:"average"`
	Amount    float64 `json:"amount"`
	Filled    float64 `json:"filled"`
	Status    int64   `json:"status"`
	Fee       float64 `json:"fee"`
	FeeType   string  `json:"fee_type"`
	UpdateAt  int64   `json:"update_at"`
}

func (q *Queries) AddExOrder(ctx context.Context, arg AddExOrderParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addExOrder,
		arg.TaskID,
		arg.InoutID,
		arg.Symbol,
		arg.Enter,
		arg.OrderType,
		arg.OrderID,
		arg.Side,
		arg.CreateAt,
		arg.Price,
		arg.Average,
		arg.Amount,
		arg.Filled,
		arg.Status,
		arg.Fee,
		arg.FeeType,
		arg.UpdateAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addIOrder = `-- name: AddIOrder :one
insert into iorder ("task_id", "symbol", "sid", "timeframe", "short", "status",
                    "enter_tag", "init_price", "quote_cost", "exit_tag", "leverage",
                    "enter_at", "exit_at", "strategy", "stg_ver", "max_pft_rate", "max_draw_down",
                    "profit_rate", "profit", "info")
values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    RETURNING id
`

type AddIOrderParams struct {
	TaskID      int64   `json:"task_id"`
	Symbol      string  `json:"symbol"`
	Sid         int64   `json:"sid"`
	Timeframe   string  `json:"timeframe"`
	Short       bool    `json:"short"`
	Status      int64   `json:"status"`
	EnterTag    string  `json:"enter_tag"`
	InitPrice   float64 `json:"init_price"`
	QuoteCost   float64 `json:"quote_cost"`
	ExitTag     string  `json:"exit_tag"`
	Leverage    float64 `json:"leverage"`
	EnterAt     int64   `json:"enter_at"`
	ExitAt      int64   `json:"exit_at"`
	Strategy    string  `json:"strategy"`
	StgVer      int64   `json:"stg_ver"`
	MaxPftRate  float64 `json:"max_pft_rate"`
	MaxDrawDown float64 `json:"max_draw_down"`
	ProfitRate  float64 `json:"profit_rate"`
	Profit      float64 `json:"profit"`
	Info        string  `json:"info"`
}

func (q *Queries) AddIOrder(ctx context.Context, arg AddIOrderParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addIOrder,
		arg.TaskID,
		arg.Symbol,
		arg.Sid,
		arg.Timeframe,
		arg.Short,
		arg.Status,
		arg.EnterTag,
		arg.InitPrice,
		arg.QuoteCost,
		arg.ExitTag,
		arg.Leverage,
		arg.EnterAt,
		arg.ExitAt,
		arg.Strategy,
		arg.StgVer,
		arg.MaxPftRate,
		arg.MaxDrawDown,
		arg.ProfitRate,
		arg.Profit,
		arg.Info,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addTask = `-- name: AddTask :one
insert into bottask
("mode", "name", "create_at", "start_at", "stop_at", "info")
values (?, ?, ?, ?, ?, ?)
    returning id, mode, name, create_at, start_at, stop_at, info
`

type AddTaskParams struct {
	Mode     string `json:"mode"`
	Name     string `json:"name"`
	CreateAt int64  `json:"create_at"`
	StartAt  int64  `json:"start_at"`
	StopAt   int64  `json:"stop_at"`
	Info     string `json:"info"`
}

func (q *Queries) AddTask(ctx context.Context, arg AddTaskParams) (*BotTask, error) {
	row := q.db.QueryRowContext(ctx, addTask,
		arg.Mode,
		arg.Name,
		arg.CreateAt,
		arg.StartAt,
		arg.StopAt,
		arg.Info,
	)
	var i BotTask
	err := row.Scan(
		&i.ID,
		&i.Mode,
		&i.Name,
		&i.CreateAt,
		&i.StartAt,
		&i.StopAt,
		&i.Info,
	)
	return &i, err
}

const findTask = `-- name: FindTask :one
select id, mode, name, create_at, start_at, stop_at, info from bottask
where mode = ? and name = ?
order by create_at desc
    limit 1
`

type FindTaskParams struct {
	Mode string `json:"mode"`
	Name string `json:"name"`
}

func (q *Queries) FindTask(ctx context.Context, arg FindTaskParams) (*BotTask, error) {
	row := q.db.QueryRowContext(ctx, findTask, arg.Mode, arg.Name)
	var i BotTask
	err := row.Scan(
		&i.ID,
		&i.Mode,
		&i.Name,
		&i.CreateAt,
		&i.StartAt,
		&i.StopAt,
		&i.Info,
	)
	return &i, err
}

const getExOrders = `-- name: GetExOrders :many
select id, task_id, inout_id, symbol, enter, order_type, order_id, side, create_at, price, average, amount, filled, status, fee, fee_type, update_at from exorder
where inout_id=?
`

func (q *Queries) GetExOrders(ctx context.Context, inoutID int64) ([]*ExOrder, error) {
	rows, err := q.db.QueryContext(ctx, getExOrders, inoutID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ExOrder
	for rows.Next() {
		var i ExOrder
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.InoutID,
			&i.Symbol,
			&i.Enter,
			&i.OrderType,
			&i.OrderID,
			&i.Side,
			&i.CreateAt,
			&i.Price,
			&i.Average,
			&i.Amount,
			&i.Filled,
			&i.Status,
			&i.Fee,
			&i.FeeType,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIOrder = `-- name: GetIOrder :one
select id, task_id, symbol, sid, timeframe, short, status, enter_tag, init_price, quote_cost, exit_tag, leverage, enter_at, exit_at, strategy, stg_ver, max_pft_rate, max_draw_down, profit_rate, profit, info from iorder
where id = ?
`

func (q *Queries) GetIOrder(ctx context.Context, id int64) (*IOrder, error) {
	row := q.db.QueryRowContext(ctx, getIOrder, id)
	var i IOrder
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Symbol,
		&i.Sid,
		&i.Timeframe,
		&i.Short,
		&i.Status,
		&i.EnterTag,
		&i.InitPrice,
		&i.QuoteCost,
		&i.ExitTag,
		&i.Leverage,
		&i.EnterAt,
		&i.ExitAt,
		&i.Strategy,
		&i.StgVer,
		&i.MaxPftRate,
		&i.MaxDrawDown,
		&i.ProfitRate,
		&i.Profit,
		&i.Info,
	)
	return &i, err
}

const getTask = `-- name: GetTask :one
select id, mode, name, create_at, start_at, stop_at, info from bottask
where id = ?
`

func (q *Queries) GetTask(ctx context.Context, id int64) (*BotTask, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i BotTask
	err := row.Scan(
		&i.ID,
		&i.Mode,
		&i.Name,
		&i.CreateAt,
		&i.StartAt,
		&i.StopAt,
		&i.Info,
	)
	return &i, err
}

const getTaskPairs = `-- name: GetTaskPairs :many
select distinct symbol from iorder
where task_id=? and enter_at>=? and enter_at<=?
`

type GetTaskPairsParams struct {
	TaskID    int64 `json:"task_id"`
	EnterAt   int64 `json:"enter_at"`
	EnterAt_2 int64 `json:"enter_at_2"`
}

func (q *Queries) GetTaskPairs(ctx context.Context, arg GetTaskPairsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskPairs, arg.TaskID, arg.EnterAt, arg.EnterAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var symbol string
		if err := rows.Scan(&symbol); err != nil {
			return nil, err
		}
		items = append(items, symbol)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskPairs = `-- name: ListTaskPairs :many
select symbol from iorder
where task_id = ?
  and enter_at >= ?
  and enter_at <= ?
`

type ListTaskPairsParams struct {
	TaskID    int64 `json:"task_id"`
	EnterAt   int64 `json:"enter_at"`
	EnterAt_2 int64 `json:"enter_at_2"`
}

func (q *Queries) ListTaskPairs(ctx context.Context, arg ListTaskPairsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTaskPairs, arg.TaskID, arg.EnterAt, arg.EnterAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var symbol string
		if err := rows.Scan(&symbol); err != nil {
			return nil, err
		}
		items = append(items, symbol)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
select id, mode, name, create_at, start_at, stop_at, info from bottask
order by id
`

func (q *Queries) ListTasks(ctx context.Context) ([]*BotTask, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BotTask
	for rows.Next() {
		var i BotTask
		if err := rows.Scan(
			&i.ID,
			&i.Mode,
			&i.Name,
			&i.CreateAt,
			&i.StartAt,
			&i.StopAt,
			&i.Info,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setExOrder = `-- name: SetExOrder :exec
update exorder set
                   "task_id" = ?,
                   "inout_id" = ?,
                   "symbol" = ?,
                   "enter" = ?,
                   "order_type" = ?,
                   "order_id" = ?,
                   "side" = ?,
                   "create_at" = ?,
                   "price" = ?,
                   "average" = ?,
                   "amount" = ?,
                   "filled" = ?,
                   "status" = ?,
                   "fee" = ?,
                   "fee_type" = ?,
                   "update_at" = ?
where id = ?
`

type SetExOrderParams struct {
	TaskID    int64   `json:"task_id"`
	InoutID   int64   `json:"inout_id"`
	Symbol    string  `json:"symbol"`
	Enter     bool    `json:"enter"`
	OrderType string  `json:"order_type"`
	OrderID   string  `json:"order_id"`
	Side      string  `json:"side"`
	CreateAt  int64   `json:"create_at"`
	Price     float64 `json:"price"`
	Average   float64 `json:"average"`
	Amount    float64 `json:"amount"`
	Filled    float64 `json:"filled"`
	Status    int64   `json:"status"`
	Fee       float64 `json:"fee"`
	FeeType   string  `json:"fee_type"`
	UpdateAt  int64   `json:"update_at"`
	ID        int64   `json:"id"`
}

func (q *Queries) SetExOrder(ctx context.Context, arg SetExOrderParams) error {
	_, err := q.db.ExecContext(ctx, setExOrder,
		arg.TaskID,
		arg.InoutID,
		arg.Symbol,
		arg.Enter,
		arg.OrderType,
		arg.OrderID,
		arg.Side,
		arg.CreateAt,
		arg.Price,
		arg.Average,
		arg.Amount,
		arg.Filled,
		arg.Status,
		arg.Fee,
		arg.FeeType,
		arg.UpdateAt,
		arg.ID,
	)
	return err
}

const setIOrder = `-- name: SetIOrder :exec
update iorder set
                  "task_id" = ?,
                  "symbol" = ?,
                  "sid" = ?,
                  "timeframe" = ?,
                  "short" = ?,
                  "status" = ?,
                  "enter_tag" = ?,
                  "init_price" = ?,
                  "quote_cost" = ?,
                  "exit_tag" = ?,
                  "leverage" = ?,
                  "enter_at" = ?,
                  "exit_at" = ?,
                  "strategy" = ?,
                  "stg_ver" = ?,
                  "max_pft_rate" = ?,
                  "max_draw_down" = ?,
                  "profit_rate" = ?,
                  "profit" = ?,
                  "info" = ?
WHERE id = ?
`

type SetIOrderParams struct {
	TaskID      int64   `json:"task_id"`
	Symbol      string  `json:"symbol"`
	Sid         int64   `json:"sid"`
	Timeframe   string  `json:"timeframe"`
	Short       bool    `json:"short"`
	Status      int64   `json:"status"`
	EnterTag    string  `json:"enter_tag"`
	InitPrice   float64 `json:"init_price"`
	QuoteCost   float64 `json:"quote_cost"`
	ExitTag     string  `json:"exit_tag"`
	Leverage    float64 `json:"leverage"`
	EnterAt     int64   `json:"enter_at"`
	ExitAt      int64   `json:"exit_at"`
	Strategy    string  `json:"strategy"`
	StgVer      int64   `json:"stg_ver"`
	MaxPftRate  float64 `json:"max_pft_rate"`
	MaxDrawDown float64 `json:"max_draw_down"`
	ProfitRate  float64 `json:"profit_rate"`
	Profit      float64 `json:"profit"`
	Info        string  `json:"info"`
	ID          int64   `json:"id"`
}

func (q *Queries) SetIOrder(ctx context.Context, arg SetIOrderParams) error {
	_, err := q.db.ExecContext(ctx, setIOrder,
		arg.TaskID,
		arg.Symbol,
		arg.Sid,
		arg.Timeframe,
		arg.Short,
		arg.Status,
		arg.EnterTag,
		arg.InitPrice,
		arg.QuoteCost,
		arg.ExitTag,
		arg.Leverage,
		arg.EnterAt,
		arg.ExitAt,
		arg.Strategy,
		arg.StgVer,
		arg.MaxPftRate,
		arg.MaxDrawDown,
		arg.ProfitRate,
		arg.Profit,
		arg.Info,
		arg.ID,
	)
	return err
}
